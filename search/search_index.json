{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>hide:   - navigation</p>"},{"location":"#benchmark-utils","title":"Benchmark utils","text":"<p>Utils for benchmark - wrapper over python timeit.</p> <p> </p> <p>Tested on python 3.8 - 3.12</p>"},{"location":"#install","title":"Install","text":"<p>Install from pypi:</p> <p><code>pip install benchmark_utils</code></p> <p>Or install from github repo:</p> <p><code>pip install git+https://github.com/ayasyrev/benchmark_utils.git</code></p>"},{"location":"#basic-use","title":"Basic use.","text":"<p>Lets benchmark some (dummy) functions.</p> output <pre><code>from time import sleep\n\n\ndef func_to_test_1(sleep_time: float = 0.1, mult: int = 1) -&gt; None:\n    \"\"\"simple 'sleep' func for test\"\"\"\n    sleep(sleep_time * mult)\n\n\ndef func_to_test_2(sleep_time: float = 0.11, mult: int = 1) -&gt; None:\n    \"\"\"simple 'sleep' func for test\"\"\"\n    sleep(sleep_time * mult)&lt;/details&gt;\n\n&lt;!-- cell --&gt;\n&lt;details open&gt; &lt;summary&gt;output&lt;/summary&gt;\n\nLet's create benchmark.&lt;/details&gt;\n\n&lt;!-- cell --&gt;\n&lt;details open&gt; &lt;summary&gt;output&lt;/summary&gt;\n```python\nfrom benchmark_utils import Benchmark\n```&lt;/details&gt;\n\n&lt;!-- cell --&gt;\n&lt;details open&gt; &lt;summary&gt;output&lt;/summary&gt;\n```python\nbench = Benchmark(\n    [func_to_test_1, func_to_test_2],\n)\n```&lt;/details&gt;\n\n&lt;!-- cell --&gt;\n```python\nbench\n</code></pre> output         Benchmark(func_to_test_1, func_to_test_2)  Now we can benchmark that functions.  <pre><code># we can run bench.run() or just:\nbench()\n</code></pre> output <pre></pre> <pre>\n</pre> <pre> Func name  | Sec / run\n</pre> <pre>func_to_test_1:   0.10 0.0%\n</pre> <pre>func_to_test_2:   0.11 -9.1%\n</pre>  We can run it again, all functions, some of it, exclude some and change number of repeats.  <pre><code>bench.run(num_repeats=10)\n</code></pre> output <pre></pre> <pre>\n</pre> <pre> Func name  | Sec / run\n</pre> <pre>func_to_test_1:   0.10 0.0%\n</pre> <pre>func_to_test_2:   0.11 -9.1%\n</pre>  After run, we can print results - sorted or not, reversed, compare results with best or not.  <pre><code>bench.print_results(reverse=True)\n</code></pre> output <pre> Func name  | Sec / run\n</pre> <pre>func_to_test_2:   0.11 0.0%\n</pre> <pre>func_to_test_1:   0.10 10.0%\n</pre>  We can add functions to benchmark as list of functions (or partial) or as dictionary: `{\"name\": function}`.  output <pre><code>bench = Benchmark(\n    [\n        func_to_test_1,\n        partial(func_to_test_1, 0.12),\n        partial(func_to_test_1, sleep_time=0.11),\n    ]\n)\n```&lt;/details&gt;\n\n&lt;!-- cell --&gt;\n```python\nbench\n</code></pre> output         Benchmark(func_to_test_1, func_to_test_1(0.12), func_to_test_1(sleep_time=0.11)) <pre><code>bench.run()\n</code></pre> output <pre></pre> <pre>\n</pre> <pre> Func name  | Sec / run\n</pre> <pre>func_to_test_1:   0.10 0.0%\n</pre> <pre>func_to_test_1(sleep_time=0.11):   0.11 -9.1%\n</pre> <pre>func_to_test_1(0.12):   0.12 -16.7%\n</pre> output <pre><code>bench = Benchmark(\n    {\n        \"func_1\": func_to_test_1,\n        \"func_2\": func_to_test_2,\n    }\n)\n```&lt;/details&gt;\n\n&lt;!-- cell --&gt;\n```python\nbench\n</code></pre> output         Benchmark(func_1, func_2)  When we run benchmark script in terminal, we got pretty progress thanks to rich. Lets run example_1.py from example folder:  ![example_1](images/run_example_1.gif)  ## BenchmarkIter  With BenchmarkIter we can benchmark functions over iterables, for example read list of files or run functions with different arguments.  output <pre><code>def func_to_test_1(x: int) -&gt; None:\n    \"\"\"simple 'sleep' func for test\"\"\"\n    sleep(0.01)\n\n\ndef func_to_test_2(x: int) -&gt; None:\n    \"\"\"simple 'sleep' func for test\"\"\"\n    sleep(0.015)\n\n\ndummy_params = list(range(10))\n```&lt;/details&gt;\n\n&lt;!-- cell --&gt;\n&lt;details open&gt; &lt;summary&gt;output&lt;/summary&gt;\n```python\nfrom benchmark_utils import BenchmarkIter\n\nbench = BenchmarkIter(\n    func=[func_to_test_1, func_to_test_2],\n    item_list=dummy_params,\n)\n```&lt;/details&gt;\n\n&lt;!-- cell --&gt;\n```python\nbench()\n</code></pre> output <pre></pre> <pre>\n</pre> <pre> Func name  | Items/sec\n</pre> <pre>func_to_test_1:  97.93\n</pre> <pre>func_to_test_2:  65.25\n</pre>  We can run it again, all functions, some of it, exclude some and change number of repeats. And we can limit number of items with `num_samples` argument: `bench.run(num_samples=5)`  ## Multiprocessing  By default we tun functions in one thread. But we can use multiprocessing with `multiprocessing=True` argument: `bench.run(multiprocessing=True)` It will use all available cpu cores. And we can use `num_workers` argument to limit used cpu cores: `bench.run(multiprocessing=True, num_workers=2)`  <pre><code>bench.run(multiprocessing=True, num_workers=2)\n</code></pre> output <pre></pre> <pre>\n</pre> <pre> Func name  | Items/sec\n</pre> <pre>func_to_test_1: 173.20\n</pre> <pre>func_to_test_2: 120.80\n</pre>"},{"location":"plans/2026-02-01-inventory/","title":"UV Migration Inventory - 2026-02-01","text":""},{"location":"plans/2026-02-01-inventory/#purpose","title":"Purpose","text":"<p>Detailed inventory of current metadata, dependencies, and configuration for migration to uv-build packaging and Python 3.10-3.14 support.</p>"},{"location":"plans/2026-02-01-inventory/#1-file-contents","title":"1. File Contents","text":""},{"location":"plans/2026-02-01-inventory/#pyprojecttoml","title":"pyproject.toml","text":"<pre><code>[tool.ruff]\n# Assume Python 3.8\ntarget-version = \"py38\"\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#setupcfg","title":"setup.cfg","text":"<pre><code>[metadata]\nname = benchmark_utils\nversion = attr: benchmark_utils.version.__version__\nauthor = Yasyrev Andrei\nauthor_email = a.yasyrev@gmail.com\ndescription = Utils for benchmark.\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nurl = https://github.com/ayasyrev/benchmark_utils\nlicense = apache2\nclassifiers =\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3.11\n    Programming Language :: Python :: 3.12\n    License :: OSI Approved :: Apache Software License\n    Operating System :: OS Independent\n\n[options]\npackage_dir =\n    = src\npackages = find:\n\n[options.packages.find]\nwhere = src\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#setuppy","title":"setup.py","text":"<pre><code>from setuptools import setup\n\nREQUIREMENTS_FILENAME = \"requirements.txt\"\nREQUIREMENTS_TEST_FILENAME = \"requirements_test.txt\"\nREQUIREMENTS_DEV_FILENAME = \"requirements_dev.txt\"\n\ndef load_requirements(filename: str) -&gt; list[str]:\n    \"\"\"Load requirements from file\"\"\"\n    try:\n        with open(filename, encoding=\"utf-8\") as fh:\n            return fh.read().splitlines()\n    except FileNotFoundError:\n        return []\n\nREQUIRED = load_requirements(REQUIREMENTS_FILENAME)\nTEST_REQUIRED = load_requirements(REQUIREMENTS_TEST_FILENAME)\nDEV_REQUIRED = load_requirements(REQUIREMENTS_DEV_FILENAME)\n\nEXTRAS = {\n    \"test\": TEST_REQUIRED,\n    \"dev\": DEV_REQUIRED + TEST_REQUIRED,\n}\n\nsetup(\n    install_requires=REQUIRED,\n    extras_require=EXTRAS,\n)\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#requirementstxt","title":"requirements.txt","text":"<pre><code>rich\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#requirements_devtxt","title":"requirements_dev.txt","text":"<pre><code>black\nblack[jupyter]\ncoverage[toml]\nflake8\nisort\nmypy\nnbmetaclean\nnox\npre-commit\nruff\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#requirements_testtxt","title":"requirements_test.txt","text":"<pre><code>pytest\npytest-cov\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#githubworkflowstestsyml","title":".github/workflows/tests.yml","text":"<pre><code>name: Tests\non:\n  push:\n    branches:\n      - dev\n      - main\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python: [\"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"]\n    steps:\n    - name: Checkout\n      uses: actions/checkout@main\n    - name: Setup Python ${{ matrix.python }}\n      uses: actions/setup-python@main\n      with:\n        python-version: ${{ matrix.python }}\n        architecture: x64\n\n    - name: Install\n      run: |\n        pip install uv\n        uv pip install --system .[test] \"coverage[toml]\"\n    - name: Tests\n      run: pytest --cov\n\n    - name: Coverage\n      if: ${{ matrix.python == '3.11' }}\n      uses: codecov/codecov-action@main\n      with:\n        token: ${{ secrets.CODECOV_TOKEN }}\n        slug: ayasyrev/benchmark_utils\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#githubworkflowslintyml","title":".github/workflows/lint.yml","text":"<pre><code>name: Lint\non:\n  push:\n    branches:\n      - dev\n      - main\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@main\n    - uses: actions/setup-python@main\n      with:\n        python-version: \"3.11\"\n        architecture: x64\n    - run: pip install ruff\n    - run: ruff check .\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#githubworkflowsdeploy_docsyml","title":".github/workflows/deploy_docs.yml","text":"<pre><code>name: Deploy_docs\non:\n  push:\n    branches:\n      - main\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@main\n      - uses: actions/setup-python@main\n        with:\n          python-version: 3.x\n      - run: pip install mkdocs-material\n      - run: pip install pymdown-extensions\n      - run: mkdocs gh-deploy --force\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#noxfilepy","title":"noxfile.py","text":"<pre><code>import nox\n\n@nox.session(python=[\"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"], venv_backend=\"uv\")\ndef tests(session):\n    args = session.posargs or [\"--cov\"]\n    session.install(\"-e .[test]\")\n    session.run(\"pytest\", *args)\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#noxfile_lintpy","title":"noxfile_lint.py","text":"<pre><code>import nox\n\nlocations = \".\"\n\n@nox.session(python=[\"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"], venv_backend=\"uv\")\ndef lint_ruff(session):\n    args = session.posargs or locations\n    session.install(\"ruff\")\n    session.run(\"ruff\", \"check\", *args)\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#noxfile_covpy","title":"noxfile_cov.py","text":"<pre><code>import nox\n\n@nox.session(python=[\"3.11\"], venv_backend=\"uv\")\ndef tests_cov(session):\n    args = session.posargs or [\"--cov\"]\n    session.install(\"-e .[test]\", \"coverage[toml]\")\n    session.run(\"pytest\", *args)\n\n\n@nox.session(python=\"3.11\", venv_backend=\"uv\")\ndef coverage(session) -&gt; None:\n    \"\"\"Upload coverage data.\"\"\"\n    session.install(\"coverage[toml]\", \"codecov\")\n    session.run(\"coverage\", \"xml\", \"--fail-under=0\")\n    session.run(\"codecov\", *session.posargs)\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#readmemd","title":"README.md","text":"<pre><code>[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/benchmark-utils)](https://pypi.org/project/benchmark-utils/)\n...\nTested on python 3.8 - 3.12\n</code></pre>"},{"location":"plans/2026-02-01-inventory/#2-current-python-support-summary","title":"2. Current Python Support Summary","text":"Location Current Version(s) pyproject.toml - ruff target-version py38 setup.cfg - classifiers 3.8, 3.9, 3.10, 3.11, 3.12 .github/workflows/tests.yml - matrix 3.8, 3.9, 3.10, 3.11, 3.12 .github/workflows/lint.yml - python-version 3.11 .github/workflows/deploy_docs.yml - python-version 3.x (latest) noxfile.py - sessions 3.8, 3.9, 3.10, 3.11, 3.12 noxfile_lint.py - sessions 3.8, 3.9, 3.10, 3.11, 3.12 noxfile_cov.py - sessions 3.11 README.md - support statement 3.8 - 3.12 <p>Target after migration: 3.10, 3.11, 3.12, 3.13, 3.14</p>"},{"location":"plans/2026-02-01-inventory/#3-current-dependencies-summary","title":"3. Current Dependencies Summary","text":""},{"location":"plans/2026-02-01-inventory/#main-dependencies","title":"Main Dependencies","text":"<ul> <li><code>rich</code></li> </ul>"},{"location":"plans/2026-02-01-inventory/#test-dependencies","title":"Test Dependencies","text":"<ul> <li><code>pytest</code></li> <li><code>pytest-cov</code></li> </ul>"},{"location":"plans/2026-02-01-inventory/#dev-dependencies","title":"Dev Dependencies","text":"<ul> <li><code>black</code></li> <li><code>black[jupyter]</code></li> <li><code>coverage[toml]</code></li> <li><code>flake8</code></li> <li><code>isort</code></li> <li><code>mypy</code></li> <li><code>nbmetaclean</code></li> <li><code>nox</code></li> <li><code>pre-commit</code></li> <li><code>ruff</code></li> </ul>"},{"location":"plans/2026-02-01-inventory/#extras-groups","title":"Extras Groups","text":"<ul> <li><code>test</code> - includes test dependencies</li> <li><code>dev</code> - includes dev + test dependencies</li> </ul>"},{"location":"plans/2026-02-01-inventory/#4-uv-usage-confirmation","title":"4. UV Usage Confirmation","text":"<p>\u2705 UV is already used in the following locations:</p> <ol> <li>noxfile.py - <code>venv_backend=\"uv\"</code> parameter on test sessions</li> <li>noxfile_lint.py - <code>venv_backend=\"uv\"</code> parameter on lint sessions</li> <li>noxfile_cov.py - <code>venv_backend=\"uv\"</code> parameter on coverage sessions</li> <li>.github/workflows/tests.yml - <code>pip install uv</code> followed by <code>uv pip install --system .[test] \"coverage[toml]\"</code></li> </ol> <p>Conclusion: Project already uses uv for local development (nox) and CI testing. Only packaging metadata migration remains.</p>"},{"location":"plans/2026-02-01-inventory/#5-files-to-remove-after-migration","title":"5. Files to Remove After Migration","text":""},{"location":"plans/2026-02-01-inventory/#setupcfg_1","title":"setup.cfg","text":"<p>Rationale: Superseded by pyproject.toml [project] section in uv-build. All metadata (name, version, author, classifiers, etc.) will be moved to pyproject.toml.</p>"},{"location":"plans/2026-02-01-inventory/#setuppy_1","title":"setup.py","text":"<p>Rationale: Superseded by pyproject.toml [project] and [project.optional-dependencies] sections. Dynamic requirement loading will be replaced with static dependency declarations in pyproject.toml.</p>"},{"location":"plans/2026-02-01-inventory/#requirementstxt_1","title":"requirements.txt","text":"<p>Rationale: Main dependencies will be moved to pyproject.toml [project.dependencies].</p>"},{"location":"plans/2026-02-01-inventory/#requirements_devtxt_1","title":"requirements_dev.txt","text":"<p>Rationale: Dev dependencies will be moved to pyproject.toml [project.optional-dependencies] under the \"dev\" extra.</p>"},{"location":"plans/2026-02-01-inventory/#requirements_testtxt_1","title":"requirements_test.txt","text":"<p>Rationale: Test dependencies will be moved to pyproject.toml [project.optional-dependencies] under the \"test\" extra.</p> <p>Migration approach: 1. Consolidate all dependencies into pyproject.toml 2. Create uv.lock with <code>uv lock</code> 3. Verify CI and nox work with new configuration 4. Remove legacy files (setup.cfg, setup.py, requirements*.txt) 5. Update Python version declarations from 3.8-3.12 to 3.10-3.14</p>"},{"location":"plans/2026-02-01-inventory/#6-migration-task-checklist","title":"6. Migration Task Checklist","text":"<ul> <li>[ ] Update pyproject.toml with [project] section</li> <li>[ ] Move dependencies to pyproject.toml</li> <li>[ ] Update Python version declarations to 3.10-3.14</li> <li>[ ] Run <code>uv lock</code> to generate lockfile</li> <li>[ ] Update CI workflows to use 3.10-3.14 matrix</li> <li>[ ] Update nox sessions to use 3.10-3.14</li> <li>[ ] Update README.md support statement</li> <li>[ ] Test locally with nox</li> <li>[ ] Verify CI passes</li> <li>[ ] Remove setup.cfg, setup.py, requirements*.txt</li> <li>[ ] Commit changes</li> </ul>"},{"location":"plans/2026-02-01-uv-migration/","title":"UV Migration Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Migrate packaging and tooling to uv, and set Python support to 3.10\u20133.14.</p> <p>Architecture: Use PEP 621 metadata in <code>pyproject.toml</code> with <code>uv-build</code> backend, and move dependency declarations into <code>[project]</code> and extras. Replace legacy config/requirements files and update automation to use uv.</p> <p>Tech Stack: Python, uv, uv-build (PEP 517), nox, pytest, ruff, GitHub Actions.</p>"},{"location":"plans/2026-02-01-uv-migration/#task-1-inventory-current-metadata-and-dependencies","title":"Task 1: Inventory current metadata and dependencies","text":"<p>Files: - Read: <code>pyproject.toml</code> - Read: <code>setup.cfg</code> - Read: <code>setup.py</code> - Read: <code>requirements.txt</code> - Read: <code>requirements_dev.txt</code> - Read: <code>requirements_test.txt</code> - Read: <code>.github/workflows/tests.yml</code> - Read: <code>.github/workflows/lint.yml</code> - Read: <code>.github/workflows/deploy_docs.yml</code> - Read: <code>noxfile.py</code> - Read: <code>noxfile_lint.py</code> - Read: <code>noxfile_cov.py</code> - Read: <code>README.md</code></p> <p>Step 1: Record current Python versions and deps - Note current <code>ruff</code> target-version, classifiers, test matrix, nox sessions, and README support claims. - Confirm uv usage in CI and nox.</p> <p>Step 2: Decide removals - Default: remove <code>setup.cfg</code>, <code>setup.py</code>, <code>requirements*.txt</code> after moving content to <code>pyproject.toml</code> and <code>uv.lock</code>.</p>"},{"location":"plans/2026-02-01-uv-migration/#task-2-update-pyprojecttoml-for-uv-build-pep-621","title":"Task 2: Update <code>pyproject.toml</code> for uv-build + PEP 621","text":"<p>Files: - Modify: <code>pyproject.toml</code></p> <p>Step 1: Add PEP 621 metadata - Add <code>[build-system]</code> with <code>build-backend = \"uv_build\"</code> and <code>requires = [\"uv-build\"]</code>. - Add <code>[project]</code> with name, version (existing attr), description, readme, license, authors, urls. - Add <code>requires-python = \"&gt;=3.10,&lt;3.15\"</code>. - Add classifiers for 3.10\u20133.14.</p> <p>Step 2: Move dependencies - <code>[project.dependencies]</code> contains <code>rich</code>. - <code>[project.optional-dependencies]</code>:   - <code>test = [\"pytest\", \"pytest-cov\"]</code>   - <code>dev = [\"black\", \"black[jupyter]\", \"coverage[toml]\", \"flake8\", \"isort\", \"mypy\", \"nbmetaclean\", \"nox\", \"pre-commit\", \"ruff\"]</code></p> <p>Step 3: Update ruff target - Set <code>target-version = \"py310\"</code>.</p>"},{"location":"plans/2026-02-01-uv-migration/#task-3-remove-legacy-packaging-files","title":"Task 3: Remove legacy packaging files","text":"<p>Files: - Delete: <code>setup.cfg</code> - Delete: <code>setup.py</code> - Delete: <code>requirements.txt</code> - Delete: <code>requirements_dev.txt</code> - Delete: <code>requirements_test.txt</code></p> <p>Step 1: Remove files after <code>pyproject.toml</code> is complete - Ensure no tooling still references these files.</p>"},{"location":"plans/2026-02-01-uv-migration/#task-4-update-nox-sessions-for-python-310314","title":"Task 4: Update nox sessions for Python 3.10\u20133.14","text":"<p>Files: - Modify: <code>noxfile.py</code> - Modify: <code>noxfile_lint.py</code> - Modify: <code>noxfile_cov.py</code></p> <p>Step 1: Update version lists - Replace 3.8/3.9 with 3.10\u20133.14 in <code>python=[...]</code>. - Keep coverage session pinned to a single version (recommend 3.12 or 3.13).</p>"},{"location":"plans/2026-02-01-uv-migration/#task-5-update-github-actions-ci","title":"Task 5: Update GitHub Actions CI","text":"<p>Files: - Modify: <code>.github/workflows/tests.yml</code> - Modify: <code>.github/workflows/lint.yml</code> - Modify: <code>.github/workflows/deploy_docs.yml</code></p> <p>Step 1: Tests matrix - Set matrix to <code>[\"3.10\", \"3.11\", \"3.12\", \"3.13\", \"3.14\"]</code>.</p> <p>Step 2: Lint - Use a stable single version (3.12 or 3.13).</p> <p>Step 3: Docs - Pin to a stable single version (3.12 or 3.13).</p> <p>Step 4: uv install - Prefer <code>uv pip install --system .[test]</code> or <code>uv sync --extra test</code> (align with chosen workflow).</p>"},{"location":"plans/2026-02-01-uv-migration/#task-6-update-readme-and-badges","title":"Task 6: Update README and badges","text":"<p>Files: - Modify: <code>README.md</code></p> <p>Step 1: Update support statement - Replace \"Tested on python 3.8 - 3.12\" with \"Tested on python 3.10 - 3.14\".</p> <p>Step 2: Install instructions - Add uv-based install snippet (e.g., <code>uv pip install -e .[test]</code>).</p>"},{"location":"plans/2026-02-01-uv-migration/#task-7-generate-uv-lockfile","title":"Task 7: Generate uv lockfile","text":"<p>Files: - Create: <code>uv.lock</code></p> <p>Step 1: Sync - Run <code>uv sync --extra test</code> to generate <code>uv.lock</code>. - Ensure lock captures extras.</p>"},{"location":"plans/2026-02-01-uv-migration/#task-8-verification","title":"Task 8: Verification","text":"<p>Step 1: Lint - Run <code>ruff check .</code>.</p> <p>Step 2: Tests - Run <code>pytest --cov</code> (or via nox on one version).</p> <p>Step 3: Build metadata - Run <code>uv build</code> (or <code>python -m build</code> if needed) and confirm success.</p>"},{"location":"plans/2026-02-01-uv-migration/#task-9-cleanup-and-commit","title":"Task 9: Cleanup and commit","text":"<p>Step 1: Review git status - Ensure only expected files changed.</p> <p>Step 2: Commit - Commit message example: <code>chore: migrate packaging to uv-build and update python support</code>.</p> <p>Open decisions (defaults proposed): - Coverage/lint Python version: default to 3.12 (stable). - Keep <code>requirements*.txt</code> as exports? default: remove entirely.</p>"},{"location":"plans/2026-02-01-version-from-pyproject/","title":"Version From Pyproject Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace the hardcoded <code>__version__</code> with a runtime value sourced from package metadata, with a fallback to <code>pyproject.toml</code>.</p> <p>Architecture: At import time, <code>get_version()</code> tries <code>importlib.metadata.version(\"benchmark_utils\")</code>. If metadata is unavailable, it reads <code>pyproject.toml</code> near the repo root and extracts <code>[project].version</code>. If neither source is available, it returns <code>\"0.0.0\"</code> to keep imports safe. The public API remains <code>benchmark_utils.__version__</code>.</p> <p>Tech Stack: Python 3.10+, stdlib <code>importlib.metadata</code>, <code>tomllib</code> (3.11+), optional minimal parser fallback.</p>"},{"location":"plans/2026-02-01-version-from-pyproject/#task-1-add-runtime-version-resolution-in-version-module","title":"Task 1: Add runtime version resolution in version module","text":"<p>Files: - Modify: <code>src/benchmark_utils/version.py</code></p> <p>Step 1: Write the failing test Create <code>tests/test_version.py</code> with a test that asserts <code>__version__</code> matches a stubbed <code>importlib.metadata.version</code>.</p> <pre><code>import importlib\nimport importlib.metadata as metadata\n\nimport benchmark_utils.version as version_mod\n\n\ndef test_version_from_metadata(monkeypatch):\n    def fake_version(_: str) -&gt; str:\n        return \"9.9.9\"\n\n    monkeypatch.setattr(metadata, \"version\", fake_version)\n    importlib.reload(version_mod)\n    assert version_mod.__version__ == \"9.9.9\"\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/test_version.py::test_version_from_metadata -v</code> Expected: FAIL because <code>__version__</code> is still hardcoded.</p> <p>Step 3: Write minimal implementation</p> <p>In <code>src/benchmark_utils/version.py</code>, implement:</p> <pre><code>from __future__ import annotations\n\nfrom importlib import metadata\nfrom pathlib import Path\n\ntry:\n    import tomllib\nexcept ModuleNotFoundError:  # pragma: no cover\n    tomllib = None\n\n\ndef _read_version_from_pyproject() -&gt; str | None:\n    pyproject_path = Path(__file__).resolve().parents[2] / \"pyproject.toml\"\n    if not pyproject_path.exists():\n        return None\n\n    data: dict[str, object] | None = None\n    if tomllib is not None:\n        with pyproject_path.open(\"rb\") as handle:\n            data = tomllib.load(handle)\n    else:\n        # Minimal parser fallback for py3.10\n        current_section = None\n        version_value = None\n        with pyproject_path.open(\"r\", encoding=\"utf-8\") as handle:\n            for line in handle:\n                stripped = line.strip()\n                if stripped.startswith(\"[\") and stripped.endswith(\"]\"):\n                    current_section = stripped.strip(\"[]\")\n                elif current_section == \"project\" and stripped.startswith(\"version\"):\n                    _, value = stripped.split(\"=\", 1)\n                    version_value = value.strip().strip('\"').strip(\"'\")\n                    break\n        if version_value is not None:\n            return version_value\n    if isinstance(data, dict):\n        project = data.get(\"project\", {})\n        if isinstance(project, dict):\n            version = project.get(\"version\")\n            if isinstance(version, str):\n                return version\n    return None\n\n\ndef get_version() -&gt; str:\n    try:\n        return metadata.version(\"benchmark_utils\")\n    except metadata.PackageNotFoundError:\n        return _read_version_from_pyproject() or \"0.0.0\"\n\n\n__version__ = get_version()  # pragma: no cover\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/test_version.py::test_version_from_metadata -v</code> Expected: PASS.</p> <p>Step 5: Commit</p> <pre><code>git add src/benchmark_utils/version.py tests/test_version.py\ngit commit -m \"fix: derive version from package metadata\"\n</code></pre>"},{"location":"plans/2026-02-01-version-from-pyproject/#task-2-add-fallback-test-for-pyprojecttoml","title":"Task 2: Add fallback test for pyproject.toml","text":"<p>Files: - Modify: <code>tests/test_version.py</code></p> <p>Step 1: Write the failing test</p> <p>Add test that forces <code>PackageNotFoundError</code> and asserts fallback to the version in <code>pyproject.toml</code>:</p> <pre><code>def test_version_from_pyproject(monkeypatch):\n    def fake_version(_: str) -&gt; str:\n        raise metadata.PackageNotFoundError\n\n    monkeypatch.setattr(metadata, \"version\", fake_version)\n    importlib.reload(version_mod)\n    assert version_mod.__version__ == \"0.2.5b1\"\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/test_version.py::test_version_from_pyproject -v</code> Expected: FAIL until fallback is implemented.</p> <p>Step 3: Write minimal implementation</p> <p>If not already included in Task 1, ensure <code>_read_version_from_pyproject()</code> is implemented as above.</p> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/test_version.py::test_version_from_pyproject -v</code> Expected: PASS.</p> <p>Step 5: Commit</p> <pre><code>git add tests/test_version.py src/benchmark_utils/version.py\ngit commit -m \"test: cover pyproject version fallback\"\n</code></pre>"},{"location":"plans/2026-02-01-version-from-pyproject/#task-3-run-full-test-suite","title":"Task 3: Run full test suite","text":"<p>Files: - Test: <code>tests/</code></p> <p>Step 1: Run tests</p> <p>Run: <code>pytest -v</code> Expected: PASS.</p> <p>Step 2: Commit (if any changes)</p> <pre><code>git status\n</code></pre> <p>If clean, no commit required.</p>"},{"location":"plans/2026-02-01-version-resolution-hardening/","title":"Version Resolution Hardening Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Make version resolution robust across Python 3.10\u20133.14 with clear warnings on failures, correct dependency handling, and comprehensive tests.</p> <p>Architecture: Keep <code>get_version()</code> as the entry point. Use <code>importlib.metadata.version</code> first; on <code>PackageNotFoundError</code>, fall back to <code>_read_version_from_pyproject()</code>. Introduce <code>_VERSION_UNKNOWN = \"UNKNOWN\"</code> and emit warnings for missing/invalid TOML or IO errors. Add <code>_find_pyproject_toml()</code> for robust path lookup and <code>_load_tomllib()</code> for tomllib/tomli availability.</p> <p>Tech Stack: Python 3.10+, pytest, importlib.metadata, tomllib/tomli, warnings.</p>"},{"location":"plans/2026-02-01-version-resolution-hardening/#task-0-prep-worktree-required","title":"Task 0: Prep worktree (required)","text":"<p>Files: none Step 1: Create isolated worktree Run: <code>@using-git-worktrees</code> Expected: new worktree ready for edits.</p>"},{"location":"plans/2026-02-01-version-resolution-hardening/#task-1-add-conditional-tomli-dependency","title":"Task 1: Add conditional tomli dependency","text":"<p>Files: - Modify: <code>pyproject.toml</code></p> <p>Step 1: Update dependencies Set: <pre><code>dependencies = [\n    \"rich\",\n    \"tomli&gt;=2.0.0; python_version&lt;'3.11'\"\n]\n</code></pre></p> <p>Step 2: Verify pyproject parses Run: <code>python -c \"import tomllib; tomllib.load(open('pyproject.toml','rb'))\"</code> Expected: exit code 0</p> <p>Step 3: Commit <pre><code>git add pyproject.toml\ngit commit -m \"chore: add tomli fallback for py310\"\n</code></pre></p>"},{"location":"plans/2026-02-01-version-resolution-hardening/#task-2-harden-version-resolution-logic","title":"Task 2: Harden version resolution logic","text":"<p>Files: - Modify: <code>src/benchmark_utils/version.py</code></p> <p>Step 1: Write failing tests (stubs) Add placeholders in <code>tests/test_version.py</code> for: - missing pyproject -&gt; UNKNOWN + warning - malformed TOML -&gt; UNKNOWN + warning - missing tomllib/tomli -&gt; UNKNOWN + warning - missing version field -&gt; UNKNOWN + warning - metadata available -&gt; metadata value - metadata missing -&gt; pyproject value</p> <p>Step 2: Run tests to confirm failures Run: <code>uv run pytest tests/test_version.py -v</code> Expected: FAILs</p> <p>Step 3: Implement minimal code changes Add: - <code>_VERSION_UNKNOWN = \"UNKNOWN\"</code> - <code>_load_tomllib()</code> to handle tomllib/tomli missing with warnings - <code>_find_pyproject_toml()</code> walking up directories (depth-limited) - <code>_read_version_from_pyproject()</code> that:   - warns on missing pyproject   - warns on IO errors   - warns on TOML decode errors   - warns on missing <code>[project].version</code>   - returns <code>_VERSION_UNKNOWN</code> in all warning cases - Narrow <code>get_version()</code> except to <code>importlib.metadata.PackageNotFoundError</code></p> <p>Step 4: Run targeted tests Run: <code>uv run pytest tests/test_version.py -v</code> Expected: PASS</p> <p>Step 5: Commit <pre><code>git add src/benchmark_utils/version.py\ngit commit -m \"fix: harden version resolution and warnings\"\n</code></pre></p>"},{"location":"plans/2026-02-01-version-resolution-hardening/#task-3-update-and-expand-tests","title":"Task 3: Update and expand tests","text":"<p>Files: - Modify: <code>tests/test_version.py</code></p> <p>Step 1: Avoid reload-based tests Call <code>version_mod.get_version()</code> directly instead of reloading and reading <code>__version__</code>.</p> <p>Step 2: Implement tests - Metadata success path - Metadata missing -&gt; pyproject value (read from real <code>pyproject.toml</code>) - Missing pyproject -&gt; UNKNOWN + warning - Missing tomllib/tomli -&gt; UNKNOWN + warning - Malformed TOML -&gt; UNKNOWN + warning - Missing version field -&gt; UNKNOWN + warning</p> <p>Step 3: Run tests Run: <code>uv run pytest tests/test_version.py -v</code> Expected: PASS</p> <p>Step 4: Commit <pre><code>git add tests/test_version.py\ngit commit -m \"test: cover version fallbacks and warnings\"\n</code></pre></p>"},{"location":"plans/2026-02-01-version-resolution-hardening/#task-4-full-verification","title":"Task 4: Full verification","text":"<p>Files: none</p> <p>Step 1: Run full suite Run: <code>uv run pytest -v</code> Expected: PASS</p> <p>Step 2: Commit Only if additional fixes required.</p>"},{"location":"reviews/2026-02-01-version-pr-review/","title":"PR Review: Dynamic Version Resolution","text":"<p>Commits Reviewed: ecc995c, f760891 Review Date: 2026-02-01 Reviewers: code-reviewer, pr-test-analyzer, silent-failure-hunter agents</p>"},{"location":"reviews/2026-02-01-version-pr-review/#executive-summary","title":"Executive Summary","text":"<p>The implementation of dynamic version resolution has 6 Critical issues and 7 Important issues that need to be addressed before merging. The most significant concerns are:</p> <ol> <li>Missing <code>tomli</code> dependency will cause runtime crashes on Python 3.10</li> <li>Silent failure pattern - all errors return \"0.0.0\" without logging</li> <li>Overly broad exception handling that masks programming errors</li> </ol>"},{"location":"reviews/2026-02-01-version-pr-review/#files-changed","title":"Files Changed","text":"<ul> <li><code>src/benchmark_utils/version.py</code> - Dynamic version resolution implementation</li> <li><code>tests/test_version.py</code> - New test file with 2 tests</li> <li><code>docs/plans/2026-02-01-version-from-pyproject.md</code> - Plan documentation</li> </ul>"},{"location":"reviews/2026-02-01-version-pr-review/#critical-issues-6-found","title":"Critical Issues (6 found)","text":""},{"location":"reviews/2026-02-01-version-pr-review/#1-missing-tomli-dependency-for-python-310","title":"1. Missing tomli dependency for Python 3.10","text":"<p>Agent: code-reviewer File: <code>pyproject.toml</code> (dependencies) Confidence: 95 Line: N/A - dependency not added</p> <p>Issue: The code attempts to import <code>tomli</code> as a fallback for Python 3.10, but <code>tomli</code> is not listed in <code>pyproject.toml</code> dependencies. The project specifies <code>requires-python = \"&gt;=3.10,&lt;3.15\"</code> and includes Python 3.10 support, but the fallback will fail on Python 3.10 systems without <code>tomli</code> installed.</p> <p>Fix: Add conditional dependency to <code>pyproject.toml</code>: <pre><code>dependencies = [\n    \"rich\",\n    \"tomli&gt;=2.0.0; python_version&lt;'3.11'\"\n]\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#2-overly-broad-except-exception-masks-errors","title":"2. Overly broad <code>except Exception</code> masks errors","text":"<p>Agent: code-reviewer, silent-failure-hunter File: <code>src/benchmark_utils/version.py:42</code> Confidence: 90</p> <p>Issue: <code>except Exception:</code> catches everything including <code>ImportError</code>, <code>AttributeError</code>, <code>TypeError</code>, <code>MemoryError</code>, <code>KeyboardInterrupt</code>, <code>SystemExit</code>, and any other unexpected exception. Programming errors like passing wrong argument types would be silently caught.</p> <p>Hidden Errors: - Programming errors (wrong argument types) - System-level failures (memory errors) - Interrupts during version lookup - Import corruption issues</p> <p>Fix: <pre><code>try:\n    from importlib.metadata import version\n    return version(\"benchmark_utils\")\nexcept importlib.metadata.PackageNotFoundError:\n    return _read_version_from_pyproject()\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#3-module-import-crash-when-tomli-unavailable-on-python-310","title":"3. Module import crash when tomli unavailable on Python 3.10","text":"<p>Agent: code-reviewer, silent-failure-hunter File: <code>src/benchmark_utils/version.py:17-19</code> Confidence: 85</p> <p>Issue: When <code>tomllib</code> is not available (Python 3.10), the code attempts to import <code>tomli</code>. If <code>tomli</code> is not installed, an unhandled <code>ModuleNotFoundError</code> will crash the module import with a cryptic error message.</p> <p>User Impact: Users on Python 3.10 who install the package without dev dependencies will see a raw <code>ModuleNotFoundError</code> that doesn't explain what to do.</p> <p>Fix: <pre><code>try:\n    import tomllib\nexcept ModuleNotFoundError:\n    try:\n        import tomli as tomllib\n    except ModuleNotFoundError:\n        raise RuntimeError(\n            \"Cannot determine package version: benchmark_utils requires either \"\n            \"Python 3.11+ (for built-in tomllib) or tomli installed. \"\n            \"Install tomli with: pip install tomli\"\n        )\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#4-no-test-for-missing-pyprojecttoml-fallback","title":"4. No test for missing pyproject.toml fallback","text":"<p>Agent: pr-test-analyzer File: <code>tests/test_version.py</code> (missing test) Rating: 9/10 Lines: 24-25</p> <p>Issue: Lines 24-25 (the exception handler returning \"0.0.0\") are not tested. This code executes when <code>pyproject.toml</code> is missing, unreadable, or when file operations fail. This is the ultimate fallback and must work.</p> <p>What could break: - Development environments where <code>pyproject.toml</code> was accidentally deleted - Docker containers where file mounting failed - Corrupted filesystems - Permission issues preventing file reads</p> <p>Test to add: <pre><code>def test_version_fallback_to_zero_when_pyproject_missing(monkeypatch, tmp_path):\n    \"\"\"Test that version returns '0.0.0' when metadata unavailable and pyproject.toml missing\"\"\"\n\n    def fake_version_raises(_: str) -&gt; str:\n        raise Exception(\"metadata unavailable\")\n\n    monkeypatch.setattr(metadata, \"version\", fake_version_raises)\n\n    # Patch Path to point to non-existent directory\n    import benchmark_utils.version as version_mod\n    original_path = Path(version_mod.__file__).parent\n\n    def mock_parent(self):\n        return tmp_path  # Directory without pyproject.toml\n\n    monkeypatch.setattr(Path, \"parent\", property(mock_parent))\n    importlib.reload(version_mod)\n\n    assert version_mod.__version__ == \"0.0.0\"\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#5-000-fallback-masks-all-errors-silently","title":"5. \"0.0.0\" fallback masks all errors silently","text":"<p>Agent: silent-failure-hunter File: <code>src/benchmark_utils/version.py:25, 42</code> Severity: CRITICAL</p> <p>Issue: The function returns \"0.0.0\" as a fallback in multiple scenarios. This is misleading because:</p> <ol> <li>\"0.0.0\" is a valid semantic version that means something specific (initial development)</li> <li>Users might think they're running version 0.0.0 when they're actually in an error state</li> <li>Code checking <code>if __version__ == \"0.0.0\"</code> can't distinguish between actual version 0.0.0 and error state</li> <li>Errors in version detection propagate silently through the system</li> </ol> <p>User Impact: - Dependency resolution tools might treat \"0.0.0\" as a real version - Bug reports will include incorrect version information - Users can't detect when version resolution failed - Downstream tools that rely on accurate versioning will malfunction</p> <p>Recommended Fix: Use \"UNKNOWN\" sentinel and add warnings: <pre><code>import warnings\n\n_VERSION_UNKNOWN = \"UNKNOWN\"\n\ndef _read_version_from_pyproject() -&gt; str:\n    try:\n        # ... existing code ...\n    except FileNotFoundError:\n        warnings.warn(\n            f\"pyproject.toml not found at {pyproject_path}, \"\n            f\"version will be reported as '{_VERSION_UNKNOWN}'\"\n        )\n        return _VERSION_UNKNOWN\n    except OSError as e:\n        warnings.warn(\n            f\"Cannot read {pyproject_path}: {e}, \"\n            f\"version will be reported as '{_VERSION_UNKNOWN}'\"\n        )\n        return _VERSION_UNKNOWN\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#6-no-test-for-python-310-without-tomli","title":"6. No test for Python 3.10 without tomli","text":"<p>Agent: pr-test-analyzer File: <code>tests/test_version.py</code> (missing test) Rating: 8/10 Lines: 17-19</p> <p>Issue: When <code>tomllib</code> is not available (Python 3.10), the code attempts to import <code>tomli</code>. If <code>tomli</code> is not installed, an unhandled <code>ModuleNotFoundError</code> will crash the module import.</p> <p>Test to add: <pre><code>def test_python_310_without_tomli_graceful_fallback(monkeypatch):\n    \"\"\"Test that Python 3.10 without tomli falls back to 0.0.0 rather than crashing\"\"\"\n\n    def fake_version_raises(_: str) -&gt; str:\n        raise Exception(\"metadata unavailable\")\n\n    monkeypatch.setattr(metadata, \"version\", fake_version_raises)\n\n    # Simulate both tomllib and tomli being unavailable\n    import builtins\n    original_import = builtins.__import__\n\n    def mock_import(name, *args, **kwargs):\n        if name in ('tomllib', 'tomli'):\n            raise ModuleNotFoundError(f\"No module named '{name}'\")\n        return original_import(name, *args, **kwargs)\n\n    monkeypatch.setattr(builtins, '__import__', mock_import)\n    importlib.reload(version_mod)\n\n    # Should fall back to 0.0.0 instead of crashing\n    assert version_mod.__version__ == \"0.0.0\"\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#important-issues-7-found","title":"Important Issues (7 found)","text":""},{"location":"reviews/2026-02-01-version-pr-review/#7-path-traversal-assumes-specific-directory-structure","title":"7. Path traversal assumes specific directory structure","text":"<p>Agent: code-reviewer File: <code>src/benchmark_utils/version.py:12</code> Confidence: 82</p> <p>Issue: <code>Path(__file__).parent.parent.parent / \"pyproject.toml\"</code> assumes the package is installed as <code>src/benchmark_utils/</code>. This breaks if: - The package is installed in editable mode with different structure - The module is imported from a different location - The code is run from a different working directory</p> <p>Fix: Implement path search walking up directory tree: <pre><code>def _find_pyproject_toml() -&gt; Path | None:\n    \"\"\"Find pyproject.toml by walking up the directory tree.\"\"\"\n    current = Path(__file__).resolve().parent\n    for _ in range(5):  # Limit traversal depth\n        if (current / \"pyproject.toml\").exists():\n            return current / \"pyproject.toml\"\n        if current.parent == current:  # Reached root\n            break\n        current = current.parent\n    return None\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#8-no-test-for-malformed-pyprojecttoml","title":"8. No test for malformed pyproject.toml","text":"<p>Agent: pr-test-analyzer File: <code>tests/test_version.py</code> (missing test) Rating: 7/10 Lines: 21-23</p> <p>Issue: The code catches <code>FileNotFoundError</code> and <code>OSError</code> but not <code>tomllib.TOMLDecodeError</code> (which occurs when the TOML file is malformed). A manually edited <code>pyproject.toml</code> with syntax errors will cause an unhandled exception.</p> <p>Test to add: <pre><code>def test_malformed_pyproject_toml(monkeypatch, tmp_path):\n    \"\"\"Test fallback to 0.0.0 when pyproject.toml is malformed\"\"\"\n\n    def fake_version_raises(_: str) -&gt; str:\n        raise Exception(\"metadata unavailable\")\n\n    monkeypatch.setattr(metadata, \"version\", fake_version_raises)\n\n    # Create a malformed pyproject.toml\n    bad_pyproject = tmp_path / \"pyproject.toml\"\n    bad_pyproject.write_text(\"[project\\nversion = '0.2.5b1'\")  # Missing closing bracket\n\n    # Patch the path resolution\n    import benchmark_utils.version as version_mod\n\n    def mock_parent(self):\n        return tmp_path.parent\n\n    monkeypatch.setattr(Path, \"parent\", property(mock_parent))\n    importlib.reload(version_mod)\n\n    assert version_mod.__version__ == \"0.0.0\"\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#9-test-reload-pattern-causes-state-pollution","title":"9. Test reload pattern causes state pollution","text":"<p>Agent: code-reviewer File: <code>tests/test_version.py:16, 27</code> Confidence: 80</p> <p>Issue: Using <code>importlib.reload()</code> in tests without cleanup can pollute module state across test runs. While tests are isolated within each function, the monkeypatch on <code>metadata.version</code> persists after the test completes.</p> <p>Fix: Consider using a fixture with cleanup or test internal functions directly: <pre><code>def test_version_from_pyproject(monkeypatch, tmp_path):\n    \"\"\"Test fallback to pyproject.toml when metadata unavailable\"\"\"\n    # Mock the version function to raise error\n    def fake_version_raises(_: str) -&gt; str:\n        raise importlib.metadata.PackageNotFoundError(\"benchmark_utils\")\n\n    monkeypatch.setattr(\n        \"benchmark_utils.version.get_version\",\n        lambda: _read_version_from_pyproject()\n    )\n    # Or test _read_version_from_pyproject() directly with a mock pyproject.toml\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#10-hardcoded-version-assertion-creates-brittleness","title":"10. Hardcoded version assertion creates brittleness","text":"<p>Agent: code-reviewer File: <code>tests/test_version.py:29</code> Confidence: 80</p> <p>Issue: The test asserts <code>version_mod.__version__ == \"0.2.5b1\"</code>, which will break whenever the version in <code>pyproject.toml</code> changes. This creates maintenance overhead.</p> <p>Fix: Read the version from <code>pyproject.toml</code> dynamically in the test: <pre><code>import tomllib\nfrom pathlib import Path\n\ndef test_version_from_pyproject(monkeypatch):\n    # Read expected version from actual pyproject.toml\n    pyproject = Path(__file__).parent.parent.parent / \"pyproject.toml\"\n    with open(pyproject, \"rb\") as f:\n        expected_version = tomllib.load(f)[\"project\"][\"version\"]\n\n    # ... rest of test\n    assert version_mod.__version__ == expected_version\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#11-missing-toml-parsing-error-context","title":"11. Missing TOML parsing error context","text":"<p>Agent: silent-failure-hunter File: <code>src/benchmark_utils/version.py:22</code> Severity: HIGH</p> <p>Issue: If <code>pyproject.toml</code> has malformed TOML, users get a raw <code>TOMLDecodeError</code> that doesn't mention which file failed to parse. Users might not realize <code>pyproject.toml</code> is the problem.</p> <p>Fix: Wrap the TOML parsing to provide better context: <pre><code>try:\n    with open(pyproject_path, \"rb\") as f:\n        data = tomllib.load(f)\nexcept tomllib.TOMLDecodeError as e:\n    raise RuntimeError(\n        f\"Failed to parse {pyproject_path}: {e}\"\n    ) from e\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#12-silent-file-read-failures-permissions-io-errors","title":"12. Silent file read failures (permissions, I/O errors)","text":"<p>Agent: silent-failure-hunter File: <code>src/benchmark_utils/version.py:24</code> Severity: CRITICAL</p> <p>Issue: The catch block for <code>(FileNotFoundError, OSError)</code> silently returns \"0.0.0\" without logging. This swallows: - <code>PermissionError</code> - User lacks read permissions - <code>IsADirectoryError</code> - <code>pyproject.toml</code> is a directory, not a file - Other <code>OSError</code> subclasses - disk I/O errors, network filesystem issues</p> <p>User Impact: - If <code>pyproject.toml</code> exists but is unreadable due to permissions, the error is silently ignored - If the file path calculation is wrong, no error is raised - Users get \"0.0.0\" when the file exists but can't be read, with no indication of the problem</p> <p>Fix: Add warnings before falling back (see Issue #5 for full implementation).</p>"},{"location":"reviews/2026-02-01-version-pr-review/#13-no-test-for-missing-version-field-in-pyprojecttoml","title":"13. No test for missing version field in pyproject.toml","text":"<p>Agent: pr-test-analyzer File: <code>tests/test_version.py</code> (missing test) Rating: 6/10 Lines: 23</p> <p>Issue: The code uses <code>.get(\"project\", {}).get(\"version\", \"0.0.0\")</code> which handles this case, but it's not explicitly tested. Adding a test documents this behavior and prevents regression.</p> <p>Test to add: <pre><code>def test_pyproject_without_version_field(monkeypatch, tmp_path):\n    \"\"\"Test that missing version field in pyproject.toml returns 0.0.0\"\"\"\n\n    def fake_version_raises(_: str) -&gt; str:\n        raise Exception(\"metadata unavailable\")\n\n    monkeypatch.setattr(metadata, \"version\", fake_version_raises)\n\n    # Create pyproject.toml without version field\n    no_version_pyproject = tmp_path / \"pyproject.toml\"\n    no_version_pyproject.write_text(\"[project]\\nname = 'benchmark_utils'\")\n\n    import benchmark_utils.version as version_mod\n\n    def mock_parent(self):\n        return tmp_path.parent\n\n    monkeypatch.setattr(Path, \"parent\", property(mock_parent))\n    importlib.reload(version_mod)\n\n    assert version_mod.__version__ == \"0.0.0\"\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#suggestions","title":"Suggestions","text":""},{"location":"reviews/2026-02-01-version-pr-review/#14-tests-couple-to-implementation-details","title":"14. Tests couple to implementation details","text":"<p>Agent: pr-test-analyzer Rating: 4/10</p> <p>Observation: The tests mock <code>importlib.metadata.version</code> directly, which is an implementation detail. If the implementation changes to use a different metadata source, the tests would fail even if behavior remains correct.</p> <p>Verdict: Acceptable given the constraints, but document why mocking is necessary in test docstrings.</p>"},{"location":"reviews/2026-02-01-version-pr-review/#strengths","title":"Strengths","text":"<ol> <li> <p>Good test naming: <code>test_version_from_metadata</code> and <code>test_version_from_pyproject</code> clearly describe what is being tested</p> </li> <li> <p>Docstrings present: Each test has a clear docstring explaining its purpose</p> </li> <li> <p>Monkeypatch used correctly: The tests properly use pytest's <code>monkeypatch</code> fixture for reversible mocking</p> </li> <li> <p>Tests the primary use case: The happy path (metadata available) and primary fallback (<code>pyproject.toml</code>) are both covered</p> </li> <li> <p>Test isolation: Each test independently sets up its mocking conditions</p> </li> <li> <p>Proper Python practices: Type annotations, docstrings, and the <code>from __future__ import annotations</code> pattern used elsewhere in the codebase</p> </li> </ol>"},{"location":"reviews/2026-02-01-version-pr-review/#recommended-action-plan","title":"Recommended Action Plan","text":""},{"location":"reviews/2026-02-01-version-pr-review/#must-fix-before-merge","title":"Must Fix Before Merge","text":"<ol> <li> <p>Add tomli dependency to <code>pyproject.toml</code>:    <pre><code>dependencies = [\"rich\", \"tomli&gt;=2.0.0; python_version&lt;'3.11'\"]\n</code></pre></p> </li> <li> <p>Fix exception handling in <code>get_version()</code>:    <pre><code>except importlib.metadata.PackageNotFoundError:\n    return _read_version_from_pyproject()\n</code></pre></p> </li> <li> <p>Add error handling for missing tomli on Python 3.10</p> </li> <li> <p>Add tests for:</p> </li> <li>Missing <code>pyproject.toml</code> returning \"0.0.0\" or \"UNKNOWN\"</li> <li>Python 3.10 without tomli</li> </ol>"},{"location":"reviews/2026-02-01-version-pr-review/#strongly-recommended","title":"Strongly Recommended","text":"<ol> <li> <p>Replace \"0.0.0\" with \"UNKNOWN\" sentinel and add warnings</p> </li> <li> <p>Add test for malformed <code>pyproject.toml</code></p> </li> <li> <p>Improve error context for TOML parsing failures</p> </li> </ol>"},{"location":"reviews/2026-02-01-version-pr-review/#nice-to-have","title":"Nice to Have","text":"<ol> <li> <p>Make tests less brittle by reading version dynamically from <code>pyproject.toml</code></p> </li> <li> <p>Implement robust path resolution instead of hardcoded traversal</p> </li> <li> <p>Consider fixture-based approach instead of <code>importlib.reload()</code></p> </li> </ol>"},{"location":"reviews/2026-02-01-version-pr-review/#verification-steps","title":"Verification Steps","text":"<p>After fixes, re-run: <pre><code># Run version tests\nuv run pytest tests/test_version.py -v\n\n# Run full test suite\nuv run pytest -v\n\n# Re-run PR review to verify issues are resolved\n</code></pre></p>"},{"location":"reviews/2026-02-01-version-pr-review/#summary-table","title":"Summary Table","text":"# Issue Severity Agent File Line 1 Missing tomli dependency CRITICAL code-reviewer pyproject.toml N/A 2 Overly broad except Exception CRITICAL code-reviewer, silent-failure-hunter version.py 42 3 Module import crash Python 3.10 CRITICAL code-reviewer, silent-failure-hunter version.py 17-19 4 No test for missing pyproject.toml CRITICAL pr-test-analyzer test_version.py N/A 5 \"0.0.0\" fallback masks errors CRITICAL silent-failure-hunter version.py 25, 42 6 No test for Python 3.10 without tomli CRITICAL pr-test-analyzer test_version.py N/A 7 Path traversal assumes structure IMPORTANT code-reviewer version.py 12 8 No test for malformed TOML IMPORTANT pr-test-analyzer test_version.py N/A 9 Test reload state pollution IMPORTANT code-reviewer test_version.py 16, 27 10 Hardcoded version assertion IMPORTANT code-reviewer test_version.py 29 11 Missing TOML error context HIGH silent-failure-hunter version.py 22 12 Silent file read failures CRITICAL silent-failure-hunter version.py 24 13 No test for missing version field IMPORTANT pr-test-analyzer test_version.py N/A 14 Tests couple to implementation SUGGESTION pr-test-analyzer test_version.py - <p>Total Issues Found: 14 (6 Critical, 7 Important, 1 Suggestion)</p>"}]}